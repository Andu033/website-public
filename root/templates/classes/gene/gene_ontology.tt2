[%#

   gene_ontology; custom data table processing used on the Gene Summary.

   This is essentially generic processing for a nested data structure
   intended to be multiple tables.

   eg. data contains a hash.array.hashrefs (instead of single tier array.hashrefs)

%]

[% go_table_settings = '
"drawCallback": function ( settings ) {
            var api = this.api();
            var rows = api.rows().nodes();
            var last=null;

            api.column(0).data().each( function ( group, i ) {
                if ( last !== group ) {
                    $jq(rows).eq( i ).before(
                        \'<tr class="group"><td colspan="5">\'+group+\'</td></tr>\'
                    );

                    last = group;
                }
            } );
},'%]
[% go_table_listener = "
.on( 'click', 'tr.group', function () {
        var table = \$jq(this).closest('table').DataTable();
        var currentOrder = table.order()[0];
        if ( currentOrder[0] === 0 && currentOrder[1] === 'asc' ) {
            table.order( [ 0, 'desc' ] ).draw();
        }
        else {
            table.order( [ 0, 'asc' ] ).draw();
        }
    } );
" %]
[%
       key="gene_ontology";
       # One table for each key (here, a GO facet)
       facets = fields.$key.data.keys.sort;

       table_count = 0;
       FOREACH facet IN facets;
            IF fields.$key.data.$facet > 0;
                WRAPPER $field_block title="$facet" key="$key";
                   table_count = table_count + 1;

                  # Here we assume that the inner data structure as an array of hashes
                  build_data_table(order = [ 'term_id', 'term', 'with', 'evidence_code', 'anno_id'],
                             columns = {   extensions   => 'Extensions',
                                                 with   => 'With',
                                                 term   => 'Term',
                                              term_id   => 'Term ID',
                                        evidence_code   => 'Evidence code' },
                             passed_data = fields.$key.data.$facet,
                         key     = "table_${table_count}_go",
    style = go_table_settings,
    listener = go_table_listener);

                 END; # END of WRAPPER
              END; # END IF facet contains data
         END; # END of facets
%]
