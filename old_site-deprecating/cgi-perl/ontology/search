#!/usr/bin/perl

# name: transgene (@ /usr/local/wormbase/cgi-perl/gene)
# author: Marcela Tello (adapted from strain script)
# date: April 2, 2003

### what this script does is to display a summary of the information
### available for a given worm Transgene in a standarized 2-column
### blue/yellow table format.

use strict;
use lib '../lib';
use ElegansSubs qw/:DEFAULT Bestname/;
use Ace::Browser::AceSubs;
use CGI qw(:standard *table escape);
use WormBase;
use vars qw/$WORMBASE $db/;

END {
  undef $WORMBASE;
  undef $db;
}

$db = OpenPageGetObject('Ontology Search',undef,1);

my $cgi = new CGI;

StartCache();

$WORMBASE = WormBase->new();

my $query;
my $ontology_list;
my @ontology_list;
my $with_annotations_only = 0;
my $data_file_name;
my $return_flag;
my $string_modification;
my $annotation_flag;
my $sort_results_by;

$string_modification = param('string_modifications');
$query = param('query');
@ontology_list = param('ontologies');
$annotation_flag = param('with_annotations_only');
$sort_results_by = param('sort');

$query=~ s/\+/ /g;
#print "$query\n";

if ($annotation_flag eq 'ON'){
    $with_annotations_only = 1;
}


$ontology_list = join '&', @ontology_list;
$data_file_name = 'search_data.txt';

my %search_results_hash = &run_search ($data_file_name, $query,$ontology_list,$with_annotations_only,$string_modification);


$return_flag = check_for_results(\%search_results_hash);

if(!($query)){
    # Do nothing;
}
elsif($return_flag == 0){

    print "<br><br>Your search for <i>$query</i> did not return any terms. Please check the spelling and try again<br><br>\n";
}
else{
     print_ontology_search_results(\%search_results_hash,$sort_results_by);
}

print_search_form($cgi);
ClosePage;

exit 0;


#######################################
#
# Subroutines
#
#######################################


sub print_search_form {
    
    my $cgi = shift @_;

    
    print $cgi->startform(-method=>'GET', 
			  -action=>'search');   

    print "<br><hr><br>Search for term, phrase, or term ID that \&nbsp\;\&nbsp;";

    my %string_choices = (#'before'=>'Starts with', 
			  #'after'=>'Followed by', 
			  'middle'=>'Contains',
			  'stand_alone'=>'Stands Alone'
			  );

    print $cgi->popup_menu(-name=>'string_modifications', 
			   -values=>[
				     #'before',
				     #'after',
				     'middle',
				     'stand_alone'], 
			   -default=>'stand_alone', 
			   -labels=>\%string_choices);
 
    
    print "<br><br>\n";

    print $cgi->textfield(-name=>'query', 
			  -size=>50, 
			  -maxlength=>80);
    
    print "<br><br>In the following ontologies\:<br><br>\n";

    my %ontologies = ('biological_process'=>'GO: Biological Process',
                      'cellular_component'=>'GO: Cellular Component',
                      'molecular_function'=>'GO: Molecular Function',
		      'anatomy'=>'Anatomy',
		      'phenotype'=>'Phenotype'
		      );

    print $cgi->scrolling_list(-name=>'ontologies', 
			       -values=>['biological_process','cellular_component','molecular_function','anatomy','phenotype'], 
			       -default=>['biological_process','cellular_component','molecular_function'], 
			       -multiple=>'true', -labels=>\%ontologies);

    print "<br><br>\n";
    print $cgi->checkbox(-name=>'with_annotations_only', 
			 -checked=>'checked', 
			 -value=>'ON', 
			 -label=>'Return Only Terms with Annotations');

    print "<br><br>Sort Annotations \&nbsp\;\&nbsp\;";
    
    my %sorting_choices = ('alpha'=>'Alphabetically',
			   'annotation_count'=>'By number of annotations'
			   );

    print $cgi->popup_menu(-name=>'sort',
                           -values=>[
                                     'alpha',
                                     'annotation_count'],
                           -default=>'alpha',
		       -labels=>\%sorting_choices);

    print "<br><br>";
    print $cgi->submit('Submit');
    print "\&nbsp\;\&nbsp\;";
    print $cgi->defaults('  Reset  ');

	print $cgi->endform;
}



sub run_search {

    my %search_results;
    my ($data_file_name, $query,$ontology_list,$annotations_only,$string_modification) = @_;
    my $search_data;

    my @ontologies = split '&',$ontology_list;
    sort @ontologies;

    if ($annotations_only == 1) {
	if #($string_modification eq 'before'){
	   # $search_data = `grep \'\\\<$query\.\* \.\/$data_file_name \| grep \-v \'\|0\'`;
	#}
	#elsif($string_modification eq 'after'){
	#    $search_data = `grep -w \*\'$query\\\>\' \.\/$data_file_name \| grep \-v \'\|0\'`;
	#}
	#elsif
	    ($string_modification eq 'stand_alone'){
	    $search_data = `grep -iw \'$query\' \.\/$data_file_name \| grep \-v \'\|0\'`;
	}
	else{
	    $search_data = `grep \'$query\' \.\/$data_file_name \| grep \-v \'\|0\'`;
	}
    }
    else {
	#if ($string_modification eq 'before'){
	#    $search_data = `grep  '\<$query.*>' \.\/$data_file_name`;
	#}
	#elsif($string_modification eq 'after'){
	#    $search_data = `grep -w \*\'\<$query' \.\/$data_file_name`;
	#    #$search_data = `grep -w \*\'$query\\\>\' \.\/$data_file_name`;
	#}
	if($string_modification eq 'stand_alone'){
	    #$search_data = `grep -w \'\\\<$query\\\>\' \.\/$data_file_name`;
	    $search_data = `grep -iw \'$query\' \.\/$data_file_name`;
	}
	else{
	    $search_data = `grep  \'$query\' \.\/$data_file_name`;
	}
    }

    $search_data =~ s/$query/\<font color\=\'red\'\>$query\<\/font\>/g;
    my @search_data_lines = split '\n', $search_data;
   
    foreach my $ontology (@ontologies){
        my $ontology_specific_line = '';
        foreach my $search_data_line (@search_data_lines){
            my @split_data = split(/\|/, $search_data_line);
            if($ontology eq $split_data[3]){
                $ontology_specific_line = $ontology_specific_line."$search_data_line\n";
            }
            else {
                next;
            }
        }
        if ($ontology_specific_line =~ m/\|/){
            $search_results{$ontology} = $ontology_specific_line;
        }
        else
        {
            $search_results{$ontology} = 0;
        }
    }
    return %search_results;
}

sub check_for_results {

    my $search_results_hash_ref;
    my $key;
    my $data;
    my $results_returned_flag = 0;

    ($search_results_hash_ref) = @_; 

    foreach $key (keys %{$search_results_hash_ref}){
        $data = ${$search_results_hash_ref}{$key};
	if($data =~ m/\|/) {
	    $results_returned_flag = 1;
	    last;
	}
	else {
	    next;
	}
    }
    return $results_returned_flag;
}

sub print_ontology_search_results {

    my $search_results_hash_ref;
    my $key;
    my $data;
    my $sort_results_by;

    ($search_results_hash_ref,$sort_results_by) = @_;

    my %ontology_names = ('biological_process', 'GO Biological Process',
		       'cellular_component', 'GO Cellular Component',
		       'molecular_function', 'GO Molecular Function',
		       'anatomy', 'Anatomy Ontology',
		       'phenotype', 'Phenotype Ontology'
    );

    my @ontology_names = sort {lc($a) cmp lc($b)} keys %ontology_names;

    my %ontology_directory = ('biological_process', 'ontology/gene',
                       'cellular_component', 'ontology/gene',
                       'molecular_function', 'ontology/gene',
                       'anatomy', 'ontology/anatomy',
                       'phenotype', 'misc/phenotype'
			  );

    ## Start table
    StartDataTable;

    ## loop through ontology data hash
    #foreach $key (keys %{$search_results_hash_ref}){
    foreach $key (@ontology_names){

	my %terms;
	my %defs;
	my %annotation_counts;
	my @sorted_ids;
	
        $data = ${$search_results_hash_ref}{$key};
	if($data =~ m/\|/){  ## data available
	    ## start row for ontology
	    StartSection($ontology_names{$key});
	    my @data = split (/\n/,$data);

	    foreach my $data_line (@data){
                if($data_line =~ 'OBSOLETE') {
                    next;
                }
                else{
                    my ($id,$term,$definition,$ontology,$annotation_count) = split (/\|/,$data_line);
		    $term =~ s/\_/ /g;
		    $terms{$id} = $term;
		    $defs{$id} = $definition;
		    $annotation_counts{$id} = $annotation_count;
                }

            }

	    if ($sort_results_by eq 'annotation_count'){		
		@sorted_ids = reverse sort { $annotation_counts{$a} <=> $annotation_counts{$b} } keys %annotation_counts; 
	    }
	    else{
		@sorted_ids = sort { lc($terms{$a}) cmp lc($terms{$b}) } keys %terms;
	    }

	    print start_table({border => 0,width=> '100%'});
	    my $term_width = '20%';
	    my $def_width = '70%';
	    my $annotation_count_width = '10%';

	    print TR({},
		     th({-align=>'left',-width=>$term_width,-class=>'databody'},'Term'),
		     th({-align=>'left',-width=>$def_width,-class=>'databody'},'Definition'),
		     th({-align=>'left',-width=>$annotation_count_width,-class=>'databody'},'Annotations')
		     );

	    foreach my $sorted_id (@sorted_ids){
		my $anchor = a({-href=>"/db/$ontology_directory{$key}\?name=$sorted_id"},$terms{$sorted_id});

		print TR({},
			 th({-align=>'left',-width=>$term_width,-class=>'databody'},$anchor),
			 th({-align=>'left',-width=>$def_width,-class=>'databody'},$defs{$sorted_id}),
			 th({-align=>'center',-width=>$annotation_count_width,-class=>'databody'},$annotation_counts{$sorted_id})
			 );

	    }
	} # end if($data =~ m/\|/){
	else {
	    next; ## skip creation of row
	} # end else
	print end_section;    
    } # end foreach $key (keys %{$search_results_hash_ref}){
    
    ## end table
EndDataTable;

} # end sub print_ontology_search_results


sub format_references {
  my @references = @_;
  my @links;
  for my $r (@references) {
    my $title    = $r->Title;
    my ($author) = $r->Author;
    my $year     = $r->Year;
    my $citation = "$author ($year). $title";
    push @links,ObjectLink($r,$citation);
  }
  @links;
}

