#++ use vars qw($DB $GFFDB $BROWSER $var $data $WORMBASE $CONFIG %EXT_LINKS);
#++ use Ace;
#++ use Ace::Browser::AceSubs qw(:DEFAULT !TypeSelector AceRedirect AceMultipleChoices Configuration);
#++ use ElegansSubs qw(:DEFAULT
#++                     GetEvidence
#++                     format_references
#++                     Bestname
#++                     GetInterpolatedPosition
                     AlleleDescription
#++                     Bestname
#++                     format_reference
#++                     GetEvidenceNew
#++                     DisplayPhenotypes
#++ 		     ParseHash
#++ );
#++ use CGI qw/:standard *table *blockquote *ul *td *TR *div *pre *span/;
#++ use Bio::Graphics::Browser;
#++ use Bio::Graphics::Panel;
#++ use Bio::Graphics::Feature;
#++ use lib '../lib';
#++ use WormBase;
#++ use WormBase::Util::Rearrange;
use WormBase::Toggle;
#++
#++ #use Carp qw(fatalsToBrowser);
#++ 
#++ # This should also present the sequence ID for affected genes.
#++ # print HTTP header & open the database
#++ #my %HIT_CACHE;
#++ 
#++ use constant PICTURE_WIDTH    => 500;
#++ use constant PADDING          => 10;
#++ use constant SEQ_STYLE        => 'font-size:12px;font-family:courier';
#++ use constant DISPLAY_ALL_TAGS => 1;
#++ use constant FULL_SEQUENCE_FLANK  => 250; # Amount of flank to use when displaying a variation in context
#++ use constant UNKNOWN          => i('unknown');
#++ use constant DEBUG            => 0;
#++ 
#++ END {
#++   undef $var;
#++   undef $data;
#++   undef $WORMBASE;
#++ }
#++ 
#++ $DB    = OpenDatabase() || AceError("Couldn't open database.");
#++
#++ # I think this is now entirely part of build_gbrowse_img...
#++ $BROWSER ||= Bio::Graphics::Browser->new or AceError('Cannot open picture generator');
#++ $BROWSER->read_configuration(Configuration->Gff_conf)  or AceError("Can't read gff configuration");
#++ $BROWSER->source('elegans');
#++ $BROWSER->width(PICTURE_WIDTH);
$BROWSER->config->set('general','empty_tracks' => 'suppress');
$BROWSER->config->set('general','keystyle'     => 'none');
#++ 
#++ $WORMBASE = WormBase->new($DB);
#++ 
#++ my $request = param('name');
#++ 
#++ # Fetch an ace object and a GFF segment in chrom coords
#++ ($data,$var,$GFFDB) = get_variation($request);# if $request;
#++ $CONFIG = Configuration();
#++ 
#++ #redirect_to_sequence($request)       if (!$var and $request);
#++ redirect_to_locus($var->New_name) if   $var and eval {$var->New_name};
#++ 
#++ PrintTop($var,'Variation',
#++ 	 $var ? "Variation report for: $var" : "Variation report");
#++ print_prompt();
#++ PrintWarning($request) if ($request && !$var);
#++ 





#++     location();
#++     genetic_info();
#++    phenotype();      # Needs work - need to display evidence, etc
#++    references();     # done
#++     history();        # done
    submit();         # done
#++     print end_table;
#++   }
#++ }
#++ 
#++ PrintBottom();
#++ 
#++ #############################
#++ ######## BEGIN SUBS #########
#++ #############################
#++ 
#++ sub get_variation {
#++   my $request = shift;
#++   return unless $request;
#++   my $class = url_param('class') || 'Variation';
#++   my ($var) = $DB->fetch(-class=>$class,
#++ 			 -name =>$request);
#++   return unless $var;
#++   my $GFFDB = OpenGFFDB($DB,$var->Species);
#++   # Create a package object for storing data
#++   my $this = Container->new($var,$GFFDB);
#++   return ($this,$var,$GFFDB);
#++ }
#++ 
#++ 
#++ sub print_prompt {
#++   $WORMBASE->print_prompt(-message  => 'Specify an allele such as',
#++ 			  -class    => 'Variation',
#++ 			  -examples => [ {'no_message' => 'e307'    },
#++ 					 {'no_message' => 'n2559'   },
#++ 					 {'no_message' => 'e345'    },
#++ 					 {'no_message' => 'pkP6112' },
#++ 				       ]);
#++   return;
#++ }
#++ 
#++ 
#++ 
#++ 
#++ 
sub submit {
  my $submit_forms = $CONFIG->Submit_forms;
  StartSection('Submit New Data');
  foreach my $hash (@$submit_forms) {
    my ($label,$href) = map { $_,$hash->{$_} } keys %$hash;
    PrintMultiple($label,a({-href=>$href,-target=>'_blank'},'[submit]'));
  }
  EndSection;
}
#++
#++ 
#++ sub phenotype {
#++     StartSection('Phenotype');
#++     DisplayPhenotypes($var->Phenotype) if $var->Phenotype;
#++ 
#++   my $description = AlleleDescription($var);
#++     SubSection('Remarks',$description) if $description ne '';
#++ 
#++   # cross-reference laboratories in the Phenotype remark
#++   my $best_description = join('; ',$var->Phenotype_remark);
#++   if ($best_description) {
#++       $best_description =~ s/;\s+([A-Z]{2})(?=[;\]])
#++ 	  /"; ".ObjectLink($1,undef,'Laboratory')
#++ 	  /exg;
#++       
#++       # cross-reference genes
#++       $best_description =~ s/\b([a-z]+-\d+)\b
#++ 	  /ObjectLink($1,undef,'Locus')
#++ 	  /exg;
#++       SubSection('Brief description',$best_description);
#++   }
#++   EndSection;
#++ }
#++
#++ sub bail {
#++  if ($var->Sequence) {
#++    print hr,h3({-class=>'heading'},
#++		"This is an allele of physical gene",ObjectLink($var->Sequence),
#++		"but no additional information is available at this time.");
#++  } else {
#++    print hr,h3({-class=>'heading'},
#++		"No additional information is available at this time.");
#++  }
#++}
#++
#++ 

#++   # This information is collected and displayed under "Location"
#++   #  my %affects = map { $_ => [$_->right] } $var->Affects;
#++   #  # Pull corresponding CDSs from the Gene
#++   #  $affects{CDS} = [ map { $_->Corresponding_CDS } @{$affects{Gene}} ] if $affects{Gene};
#++   #  foreach (qw/Gene Predicted_CDS CDS Transcript Pseudogene/) {
#++   #    my @data = eval { @{$affects{$_}} };
#++   #    next unless eval { @{$affects{$_}} > 0 };
#++   #    push(@data,UNKNOWN) unless @data;
#++   #    my $tag = lc($_);
#++   #    $tag =~ s/_/ /;
#++   #    SubSection("Affected $tag(s)",
#++   #	       join(' ',
#++   #		    map {
#++   #		      ($tag eq 'gene') ?
#++   #			a({-href=>Object2URL($_)},i(Bestname($_)))
#++   #			  :
#++   #			    ObjectLink($_)
#++   #			  } @{$affects{$_}}
#++   #		   )
#++   #	      );
#++   #  }
#++   
#++   ## Is this allele contained within a gene, but not yet associated with it?
#++   #SubSection('','NOTE:'.
#++   #	     i(" Although contained within the segments listed above, " . br .
#++   #	       "$var has not been directly associated with their function."));
#++   
#++     # Other names for the allele
#++     SubSection('Other name',$var->Other_name) if $var->Other_name;
#++     
#++     # removed by request
#++     #if ($var->Evidence) {
#++     #  print TR(th({-class=>'small',-align=>'LEFT'},'Origin:'),
#++     #	     td(GetEvidence($var->Evidence(0))));
#++     #  }
#++   
#++   my @remarks = $var->Remark;
#++     SubSection('Remarks',join(br,map { "$_: " . GetEvidenceNew(-object => $_,
#++   							     -format => 'inline',
#++   							     -display_label => 1) } @remarks)) if @remarks;
#++     
#++   }
#++ 
#++ # Only print allele information if this allele has been mapped to a gene
#++ sub genetic_info {
#++     my $gene = $var->Gene;
#++     StartSection('Genetic Information');
#++     if ($gene) {
#++ 	SubSection('Corresponding gene',map { ObjectLink($_,Bestname($_) . " ($_)") } $var->Gene);
#++ 	my $reference_allele = $var->Gene->Reference_allele;
#++ 	SubSection('Reference allele',ObjectLink($reference_allele)) if ($reference_allele);
#++ 	my @alleles = grep {$_ ne ($var || '')} $gene->Allele(-fill=>1);
#++ 	my (@clean,@poly);
#++ 	foreach (@alleles) {
#++ 	    if ($_->SNP(0)) {
#++ 		push @poly,$_;
#++ 	    } else {
#++ 		push @clean,$_;
#++ 	    }
#++ 	}
#++ 	SubSection("Other alleles",join(', ',map { ($_->Sequence || $_->Flanking_sequences) ? b(ObjectLink($_)) : ObjectLink($_)} @clean),
#++ 		   'Alleles with molecular information are shown in ' . b('boldface.')) if (@clean);
#++ 	
#++ 	SubSection("Polymorphisms",join(', ',map { ($_->Sequence || $_->Flanking_sequences) ? b(ObjectLink($_)) : ObjectLink($_)} @poly));
#++     }
#++     
#++     my @strains;
#++     foreach ($var->Strain) {
#++ 	my @genes = $_->Gene;
#++ 	my $cgc   = ($_->Location eq 'CGC') ? 1 : 0;
#++ 	my $linked = a({-href=>Object2URL($_)},$_);
#++ 	$linked = b($linked) if (@genes == 1);
#++ 	$linked = i($linked) if $cgc;
#++ 	push @strains,$linked;
#++     }
#++     
#++     SubSection("Strains carrying $var",
#++ 	       (@strains)
#++ 	       ? Tableize(\@strains,1)
#++ 	       . "Strains carrying <i>$var</i> alone are listed in "
#++ 	       . b('boldface.')
#++ 	       . br . 'Strains available directly from the CGC are ' . i('italicized.')
#++ 	       : 'none available');
#++     
#++     SubSection('Rescued by transgene',Tableize([ $var->Rescued_by_Transgene ])) if $var->Rescued_by_Transgene;
#++     EndSection;
#++ }
#++
#++ 
#++ 
#++ sub location {
#++   # Display the genomic environs of the allele, relative to a CDS if appropriate
#++   SubSection('Genomic environs',genomic_picture());
#++ } 




#++ 
#++ 
#++ sub history {
#++   StartSection('Isolation History');
#++ 
#++   my $source_db = $var->Database;
#++   if ($source_db) {
#++       my $name = $source_db->Name;      
#++       my $id   = $var->Database(3);
#++       my $url  = $source_db->URL_constructor;
#++       # Create a direct link to the external site
#++       my $request_link;
#++       if ($url && $id) {
#++ 	  $name =~ s/_/ /g;
#++           my $href = sprintf($url,$id);
#++ 	  $request_link = a({-href=>$href},"$name (external link)") ;
#++       }
#++ #      SubSection('Source',($source_db->URL ? a({-href=>$source_db->URL},$name) : $name) . $request_link);
#++       SubSection('Source',$request_link) if $request_link;
#++   }
#++ 
#++   SubSection('Author',$var->Author || UNKNOWN);
#++   my $person = join("; ",map { ObjectLink($_,$_->Full_name || $_->Standard_name) } $var->Person) if $var->Person;
#++   $person ||= UNKNOWN;
#++   SubSection('Person',$person);
#++ 
#++ 
#++   my @formatted;
#++   foreach ($var->Laboratory) {
#++   my $name  = eval { $_->Representative->Standard_name };
#++   my $place = eval { $_->Mail };
#++   push @formatted, ($name) ? ObjectLink($_) . ' (' . ObjectLink($name) . ', ' . $place . ')' : ObjectLink($_);
#++ }
#++   my $formatted = join(br,@formatted);
#++   SubSection('Laboratory of origin',$formatted || UNKNOWN);
#++   SubSection('Date isolated',$var->Date || UNKNOWN);
#++   SubSection('Mutagen',$var->Mutagen || UNKNOWN);
#++   SubSection('Isolated via forward genetics',$var->Forward_genetics) if $var->Forward_genetics;
#++   SubSection('Isolated via reverse genetics',$var->Reverse_genetics) if $var->Reverse_genetics;
#++   SubSection('Transposon excision',$var->Transposon_excision)     if ($var->Transposon_excision);
#++   
#++   # Where does this belong?
#++   SubSection('Transposon insertion',$var->Transposon_insertion)   if ($var->Transposon_insertion);
#++ 
#++   #### No longer in use, apparently
#++   ####SubSection('Knockout Consortium allele, isolated_for',$var->Isolated_for)
#++   ####  if ($var->KO_consortium_allele(0) && $var->Isolated_for);
#++ }
#++
#++ 

#++ 
#++ #####################################
#++ #  IMAGES
#++ #####################################
#++ 
#++
#++ 
#++ sub add_track {
#++   my ($panel,$features) = @_;
#++   $panel->add_track(segments     => [@$features],
#++ 		    -glyph       => $BROWSER->setting(Allele=>'glyph'),
#++ 		    -label       => 1,
#++ 		    -bump        => 1,
#++ 		    -bgcolor     => $BROWSER->setting('Allele' => 'bgcolor'),
#++ 		    -font2color  => 'blue',
#++ 		    -height      => 6,
#++ 		    -linewidth   => 1,
#++ 		    -description => $BROWSER->setting('Allele'=>'description'),
#++ 		   );
#++ }
#++ 
#++ 
#++ ##########################################
#++ # MolecularChangeHash
#++ ##########################################
#++ sub FormatMolecularChangeHash {
#++     my @p = @_;
#++     my ($data,$format,$display_tag,$link_tag,$display_label,$detail,$tag) =
#++ 	rearrange([qw/DATA FORMAT DISPLAY_TAG LINK_TAG DISPLAY_LABEL DETAIL TAG/],@p);
#++     
#++     return unless keys %$data >= 1;   # Nothing to build a table from
#++     
#++     my @types     = qw/Missense Nonsense Frameshift Silent Splice_site/;
#++     my @locations = qw/Intron Coding_exon Noncoding_exon Promoter UTR_3 UTR_5 Genomic_neighbourhood/;
#++     
#++     # Select items that we will try and translate
#++     # Currently, this needs to be
#++     # 1. Affects Predicted_CDS
#++     # 2. A missense or nonsense allele
#++     # 3. Contained in a coding_exon
#++     my %parameters_seen;
#++     my %do_translation = map { $_ => 1 } (qw/Missense Nonsense/);
#++     # Under no circumstances try and translate the following
#++     my %no_translation = map { $_ => 1 } (qw/Frameshift Deletion Insertion/);
#++ 
#++     # The following entries should be examined for the presence
#++     # of associated Evidence hashes
#++     my @with_evidence = 
#++ 	qw/
#++ 	Missense
#++ 	Silent
#++ 	Nonsense
#++ 	Splice_site
#++ 	Frameshift
#++ 	Intron
#++ 	Coding_exon
#++ 	Noncoding_exon
#++ 	Promoter
#++ 	UTR_3
#++ 	UTR_5	
#++ 	Genomic_neighbourhood
#++ 	/; 
#++     
#++     my @cells;
#++     my $table = start_table({-border=>1});
#++     foreach my $entry (@$data) {  
#++ 	my $hash  = $entry->{hash};
#++ 	my $node  = $entry->{node};
#++ 		
#++ 	# Conditionally format the data for each type of evidence
#++ 	# Curation often has the type of change and its location
#++ 	
#++ 	# What type of change is this?
#++ 	foreach my $type (@types) {
#++ 	    my $obj = $hash->{$type};
#++ 	    my @data = eval { $obj->row };
#++ 	    next unless @data;
#++ 	    my $clean_tag = ucfirst($type);
#++ 	    $clean_tag    =~ s/_/ /g;
#++ 	    $parameters_seen{$type}++;
#++ 
#++ 	    my ($pos,$text,$evi,$evi_method,$kind);
#++ 	    if ($type eq 'Missense') {
#++ 		($type,$pos,$text,$evi) = @data;
#++ 	    } elsif ($type eq 'Nonsense' || $type eq 'Splice_site') {
#++ 		($type,$kind,$text,$evi) = @data;		
#++ 	    } elsif ($type eq 'Framshift') {
#++ 		($type,$text,$evi) = @data;
#++ 	    } else { 
#++ 		($type,$text,$evi) = @data;
#++ 	    }	    
#++ 
#++ 	    if ($evi) {
#++ 		($evi_method) = GetEvidenceNew(-object => $text,
#++ 					       -format => 'inline',
#++ 					       -display_label => 1,
#++ 					       );
#++ 	    }
#++ 	    push @cells,["Effect on protein: $clean_tag",$pos || undef,$text,
#++ 			 $evi_method ? " ($evi_method)" : undef];
#++ 	}
#++ 	
#++ 	# Where is this change located?
#++ 	foreach my $location (@locations) {
#++ 	    my $obj = $hash->{$location};
#++ 	    my @data = eval { $obj->col };
#++ 	    next unless @data;
#++ 	    $parameters_seen{$location}++;
#++ 
#++ 	    my ($evidence) = GetEvidenceNew(-object => $obj,
#++ 					    -format => 'inline',
#++ 					    -display_label => 1
#++ 					    );
#++ 	    
#++ 	    my $clean_tag = ucfirst($location);
#++ 	    $clean_tag    =~ s/_/ /g;
#++ 	    push @cells,["Contained in: $clean_tag",undef,undef,
#++ 			 $evidence ? " ($evidence)" : undef];
#++ 	}
#++     }
#++     
#++     my $do_translation;
#++     foreach (keys %parameters_seen) {
#++ 	$do_translation++ if (defined $do_translation{$_}  && !defined $no_translation{$_});
#++     }
#++     return (\@cells,$do_translation);
#++ }
#++ 
#++ 
#++ 
#++
#++ 
#++  Currently resides in Model::Variation
#++  but may migrate to WormBase::Model
#++ 
#++ sub motif_picture {
#++     my ($best_only,$cds) = @_;
#++     my $cds     = $data->cds_segment($cds);;
#++     my $length  = $data->wt_trans_length;
#++     # Setup the panel, using the protein length to establish the box as a guide
#++     my $ftr = 'Bio::Graphics::Feature';
#++     my $base_segment = $ftr->new(-start=>1,-end=>$length,
#++ 				 -name => $cds->display_name,
#++ 				 -type => 'Protein');
#++     my $panel = Bio::Graphics::Panel->new(-segment   =>$base_segment,
#++ 					  -key       =>'Protein Features',
#++ 					  -key_style =>'between',
#++ 					  -key_align =>'left',
#++ 					  -grid      => 1,
#++ 					  -width     =>PICTURE_WIDTH);
#++     $panel->pad_bottom(PADDING);
#++     $panel->pad_left(PADDING);
#++     $panel->pad_right(PADDING);
#++     $panel->pad_top(PADDING);
#++     
#++     # Fetch an ace object for the current CDS
#++     my ($obj) = map {$_->Corresponding_protein} grep { $_ eq $cds->display_name } $var->Predicted_CDS;
#++     
#++     my %features;
#++     ## Structural motifs (this returns a list of feature types)
#++     my @features = $obj->Feature;
#++     # Visit each of the features, pushing into an array based on its name
#++     foreach my $type (@features) {
#++ 	# 'Tis dangereaux - could lose some features if the keys overlap...
#++ 	my %positions = map {$_ => $_->right(1)} $type->col;
#++ 	foreach my $start (keys %positions) {
#++ 	    my $seg   = $ftr->new(-start=>$start,-end=>$positions{$start},
#++ 				  -name=>"$type",-type=>$type);
#++ 	    # Create a hash of all the features, keyed by type;
#++ 	    push (@{$features{'Features-' .$type}},$seg);
#++ 	}
#++     }
#++     
#++     # A protein ruler
#++     $panel->add_track(arrow => [ $base_segment ],
#++ 		      -label => 'amino acids',
#++ 		      -arrowstyle=>'regular',
#++ 		      -tick=>5,
#++ 		      #		    -tkcolor => 'DarkGray',
#++ 		      );
#++     
#++     # Fetch and sort the exons
#++     my @exons = grep { $_->name eq $cds->display_name } $cds->features('exon:curated');
#++ 
#++     # Translate the bp start and stop positions into the approximate amino acid
#++     # contributions from the different exons.
#++     my ($count,$end_holder);
#++     my @segmented_exons;
#++     my $total_aa;
#++     foreach my $exon (sort { $a->start <=> $b->start} @exons) {
#++ 	$count++;
#++ 	my $start = $exon->start;
#++ 	my $stop  = $exon->stop;
#++ 
#++ 	# Calculate the difference of the start and stop to approximate its aa span
#++ 	my $length = (($stop - $start) / 3);
#++ 	$total_aa += $length;
#++ 	
#++ 	my $end = $length + $end_holder;
#++ 	
#++ 	my $seg = $ftr->new(-start=>$end_holder || 1,-end=>$end,
#++ 			    -name=>$count,-type=>'exon');
#++ 	push @segmented_exons,$seg;
#++ 
#++ 	# This is really the new start position
#++ 	$end_holder = $end + 1;
#++     }
#++     
#++     ## Print the exon boundaries
#++     $panel->add_track(generic=>[ @segmented_exons ],
#++ 		      -label     =>  1,  # number the exons
#++ 		      -key       => 'exon boundaries',
#++ 		      -description => 1,
#++ 		      -bump      => 0,
#++ 		      -height    => 6,
#++ 		      -spacing   => 50,
#++ 		      -linewidth =>1,
#++ 		      -connector =>'none',
#++ 		      #		  -tkcolor => $colors[rand @colors],
#++ 		      ) if @segmented_exons;
#++     
#++     
#++     foreach ($obj->Homol) {
#++ 	my (%partial,%best);
#++ 	my @hits = $obj->$_;
#++ 	
#++ 	# Let's not display pep_homols on this image
#++ 	next if ($_ eq 'Pep_homol');
#++ 	
#++ 	#    # Pep_homol data structure is a little different
#++ 	#    if ($_ eq 'Pep_homol') {
#++ 	#      my @features = wrestle_blast(\@hits,1);
#++ 	
#++ 	#      # Sort features by type.  If $best_only flag is true, then we only keep the
#++ 	#      # best ones for each type.
#++ 	#      my %best;
#++ 	#      for my $f (@features) {
#++ 	#	next if $f->name eq $obj;
#++ 	#    	my $type = $f->type;
#++ 	#   	if ($best_only) {
#++ 	#    	  next if $best{$type} && $best{$type}->score > $f->score;
#++ 	#    	  $best{$type} = $f;
#++ 	#    	} else {
#++ 	#    	  push @{$features{'BLASTP Homologies'}},$f;
#++ 	#    	}
#++ 	#      }
#++ 	
#++ 	#      # add descriptive information for each of the best ones
#++ 	#      local $^W = 0; #kill uninit variable warning
#++ 	#      for my $feature ($best_only ? values %best : @{$features{'BLASTP Homologies'}}) {
#++ 	#	my $homol = $HIT_CACHE{$feature->name};
#++ 	#	my $description = $homol->Species;
#++ 	#	my $score       = sprintf("%7.3G",10**-$feature->score);
#++ 	#	$description    =~ s/^(\w)\w* /$1. /;
#++ 	#	$description   .= " ";
#++ 	#	$description   .= $homol->Description || $homol->Gene_name;
#++ 	#	$description   .= eval{$homol->Corresponding_CDS->Brief_identification}
#++ 	#	  if $homol->Species =~ /elegans|briggsae/;
#++ 	#	my $t = $best_only ? "best hit, " : '';
#++ 	#	$feature->desc("$description (${t}e-val=$score)") if $description;
#++ 	#      }
#++ 	
#++ 	#      if ($best_only) {
#++ 	#	for my $type (keys %best) {
#++ 	#	  push @{$features{'Selected BLASTP Homologies'}},$best{$type};
#++ 	#	}
#++ 	#      }
#++ 	#      #
#++ 	#      #      # these are other homols
#++ 	#    } else {
#++ 	
#++ 	for my $homol (@hits) {
#++ 	    my $title = eval {$homol->Title};
#++ 	    my $type  = $homol->right or next;
#++ 	    my @coord = $homol->right->col;
#++ 	    my $name  = $title ? "$title ($homol)" : $homol;
#++ 	    for my $segment (@coord) {
#++ 		my ($start,$stop) = $segment->right->row;
#++ 		my $seg  = $ftr->new(-start=>$start,
#++ 				     -end =>$stop,
#++ 				     -name =>$name,
#++ 				     -type =>$type);
#++ 		push (@{$features{'Motifs'}},$seg);
#++ 	    }
#++ 	}
#++      }
#++     
#++     my %glyphs = (low_complexity => 'generic',
#++ 		  transmembrane   => 'generic',
#++ 		  signal_peptide  => 'generic',
#++ 		  tmhmm           => 'generic'
#++ 		  );
#++     
#++     my %labels   = ('low_complexity'         => 'Low Complexity',
#++ 		    'transmembrane'           => 'Transmembrane Domain(s)',
#++ 		    'signal_peptide'          => 'Signal Peptide(s)',
#++ 		    'tmhmm'                   => 'Transmembrane Domain(s)',
#++ 		    'wublastp_ensembl'        => 'BLASTP Hits on Human ENSEMBL database',
#++ 		    'wublastp_fly'            => 'BLASTP Hits on FlyBase database',
#++ 		    'wublastp_slimSwissProt'  => 'BLASTP Hits on SwissProt',
#++ 		    'wublastp_slimTrEmbl'     => 'BLASTP Hits on TREMBL',
#++ 		    'wublastp_worm'           => 'BLASTP Hits on WormPep',
#++ 		    );
#++     
#++     my %colors   = ('low_complexity' => 'blue',
#++ 		    'transmembrane'  => 'green',
#++ 		    'signalp'        => 'gray',
#++ 		    'Prosite'        => 'cyan',
#++ 		    'seg'            => 'lightgrey',
#++ 		    'Pfam'           => 'wheat',
#++ 		    'Motif_homol'    => 'orange',
#++ 		    'Pep_homol'      => 'blue'
#++ 		    );
#++     
#++     foreach my $key (sort keys %features) {
#++ 	# Get the glyph
#++ 	my $type  = $features{$key}[0]->type;
#++ 	my $label = $labels{$key}  || $key;
#++ 	my $glyph = $glyphs{$key}  || 'graded_segments';
#++ 	my $color = $colors{$type} || 'green';
#++ 	my $connector = $key eq 'Pep_homol' ? 'solid' : 'none';
#++ 	
#++ 	$panel->add_track(segments   =>$features{$key},
#++ 			  -glyph    =>$glyph,
#++ 			  -label  => ($label =~ /Features/) ? 0 : 1,
#++ 			  -bump   => 1,
#++ 			  -sort_order=>'high_score',
#++ 			  -bgcolor   =>$color,
#++ 			  -font2color => 'red',
#++ 			  -height    =>6,
#++ 			  -linewidth =>1,
#++ 			  -description=>1,
#++ 			  -min_score  =>-50,
#++ 			  -max_score  =>100,
#++ 			  -key       =>$label,
#++ 			  );
#++     }
#++     
#++     # Add in the allele position
#++     # Should conditionally select the glyph
#++     my $var_seg  = $ftr->new(-start=>$data->wt_aa_start,
#++ 			     -end =>$data->wt_aa_start,
#++ 			     -name =>$var . "(" . $data->formatted_aa_change . ")");
#++     $panel->add_track(segments     =>$var_seg,
#++ 		      -glyph       =>'diamond',
#++ 		      -label       => 1,
#++ 		      -bump        => 1,
#++ 		      -bgcolor     => ($data->aa_type eq 'Missense') ? 'yellow' : 'red',
#++ 		      -font2color  => 'red',
#++ 		      -height      => 6,
#++ 		      -linewidth   => 1,
#++ 		      -description => 1,
#++ 		      );
#++     
#++     # This will not work since I do not readily have
#++     # The amino acid positions of alleles
#++     #  my @raw_alleles = grep {$_ ne $var } $gene->features('Allele:Allele','Allele:SNP');
#++     #  my @alleles;
#++     #  foreach (@raw_alleles) {
#++     #    print $_->start/3,br;
#++     #    print $_->stop/3,br;
#++     #    my $seg  = $ftr->new(-start=>$_->start/3,
#++     #			 -end  =>$_->stop/3,
#++     #			 -name =>$_->name,
#++     #			 -type =>'Other alleles');
#++     #    push (@alleles,$seg);
#++     #  }
#++     #  print @alleles;
#++     #  $panel->add_track(segments     => [@alleles],
#++     #		    -glyph       =>'diamond',
#++     #		    -label       => 1,
#++     #		    -bump        => 1,
#++     #		    -bgcolor     =>'red',
#++     #		    -font2color  => 'red',
#++     #		    -height      =>6,
#++     #		    -linewidth   =>1,
#++     #		    -description =>1,
#++     #		    -description => 1,
#++     #		   );
#++     
#++     
#++     # turn some of the features into urls
#++     my $boxes = $panel->boxes;
#++     my $map   = '';
#++     foreach (@$boxes) {
#++ 	my ($feature,@coords) = @$_;
#++ 	my $name = $feature->name;
#++ 	my $url  = hit_to_url($name) or next;
#++ 	my $coords    = join ',',@coords;
#++ 	$map   .= qq(<area shape="rect" target="_new" coords="$coords" href="$url" />\n);
#++     }
#++     
#++     my $gd = $panel->gd;
#++     my $url = AceImage($gd);
#++     
#++     my $img = img({-src    => $url,
#++ 		   -align  => 'center',
#++ 		   -usemap => '#protein_domains',
#++ 		   -border => 0
#++ 		   });
#++     return ($img,qq(\n<map name="protein_domains">\n),$map,qq(</map>\n));
#++ }
#++ 
sub hit_to_url {
  my $name = shift;
  $name =~ /(\w+):(\w+)/ or return;
  my $prefix    = $1;
  my $accession = $2;
  my $link      = $EXT_LINKS{$prefix} or next;
  my $url       = sprintf($link,$accession);
  $url;
}



#++ # No gene found, but users often type in sequence names
#++ # and genbank accession numbers.
#++ # Try to redirect.
#++ sub redirect_to_sequence {
#++   my $gene_name = shift;
#++   my @genes;
#++   my $seq;
#++   if ($seq = $DB->fetch(Sequence => $gene_name)) {
#++     @genes = $seq->Locus;
#++   } elsif ($seq = $DB->fetch(Locus => $gene_name)) {
#++   }
#++   
#++   if (@genes) {
#++     AceMultipleChoices('gene','locus', \@genes);
#++   } else {
#++    AceRedirect('sequence' => $seq) if $seq;
#++   }
#++   exit 0;
#++ }
#++ 
#++ # Special code:
#++ # Gene name has been superseded
#++ sub redirect_to_locus {
#++   my $newlocus = shift;
#++   AceRedirect('gene',$newlocus);
#++   exit 0;
#++ }
#++ 
#++ 
#++ 
#++ 
#++ # Generic message for situtations where no information is found
#++ sub no_info {
#++   my $section = shift;
#++   return i("No $section information is available for $var or it has not yet been entered into WormBase.");
#++ }
#++
#++ 
#++ 
#++ 
#++ 1;
#++ 
#++ package Container;
#++ use Bio::Perl;
#++ use Bio::Graphics::Browser::Markup;
#++ use Bio::DB::GFF;
#++ use CGI qw/:standard/;
#++ use lib '../lib';
#++ use WormBase::Util::Rearrange;
#++ use ElegansSubs;
#++ 
#++ use strict;
#++ 
#++ # Number of bases of an indel to display before using "TYPE bp"
#++ use constant INDEL_DISPLAY_LIMIT  => '25';
#++ use constant DEBUG_ADVANCED       => 0;  # Debug advanced features
#++ use constant VARIATION_HILITE => 'color:#FFFFCC';
#++ 
#++ sub new {
#++   my ($class,$var,$GFFDB) = @_;
#++  my $this = bless {},$class;
#++   $this->{gffdb}     = $GFFDB;
#++   $this->{variation} = $var;
#++   
#++   # Fetch a genomic segment that corresponds to the allele itself
#++   # This will be a basal point from which to move outwards as necessary
#++   my $segment = $this->genomic_segment(-key => 'wt_variation');
#++ #  my $cgh_segment = $this->genome_segment(-key => 'cgh_variation');
#++ 
#++   # Package the nucleotide sequences and type of mutation
#++   # Redundant?
#++   $this->fetch_sequence_from_ace;
#++   return $this;
#++ }
#++ 
#++ # Generically fetch a genomic segment
#++ # Source should be one of mutant or wild type
#++ # This may be a segmenet spanning a single variation
#++ # Type will be used to store the segment in the object
#++ # Pass an object to fetch that segment
#++ 
#++ sub cds_segment {
#++     my ($self,$cds) = @_;
#++     my $db = $self->gff;
#++     #my ($segment) = #grep {$_->method eq 'wormbase_cds'} 
#++     
#++     my $segment = $db->segment(-name=>$cds,-class=>'Transcript');
#++     #  # Return the longest (spliced) transcript
#++     #  # This seems like a really convoluted way to get the longest transcript
#++     #  my $longest = 0;
#++     #  foreach my $gene (@gene_segments) {
#++     #    my @exons = grep { $_->name eq $gene->name } $gene->features('exon:curated');
#++     #    my $dna = join('',map {$_->dna} @exons);
#++     #    $longest = $gene if (length($dna) > $longest);
#++     #  }
#++     #  $data->add_segment('CDS',$longest);
#++     # return $longest;
#++     return $segment;
#++ }
#++ 
#++ 
#++ 

#++ #sub cgh_segments {
#++ #  my ($self,@p) = @_;
#++ #  my ($stringify) = rearrange([qw/STRINGIFY/],@p);
#++ #  my $var = $self->variation;
#++ #
#++ #  # Extract the full sequence of the deletion from GFF
#++ #  # (It is actually stored in the DB for some alleles)
#++ #  my $segment = $self->cgh_segment;
#++ #  if ($segment) {
#++ #      my ($chrom,$start,$stop) = $self->coordinates($segment);
#++ #      $wt = $segment->dna;
#++ #      if (length($wt) > INDEL_DISPLAY_LIMIT && $stringify) {
#++ #	  $wt  = length ($wt) . ' bp deletion';
#++ #      }
#++ #      $mut = '-';
#++ #  }
#++ #  push @variations,[$type,$wt,$mut];
#++ #  return \@variations;
#++ #}
#++ 
#++ 
#++ 
#++ 
#++ # The base segment is a GFF segment that contain a span of the primary allele
#++ sub base_segment { return shift->{segments}->{Variation}; }
#++
#++ 
#++ # DEPRECATING
#++ #sub cds_coordinates {
#++ #  my $self = shift;
#++ #  my $var = $self->variation;
#++ #  my $segment = $self->base_segment;
#++ #  # Eek.  What if no cds_segment?
#++ #  my $cds_segment = $self->cds_segment;
#++ #  return unless ($cds_segment);
#++ #  $segment->refseq($cds_segment);
#++ #  return ($segment->low,$segment->high);
#++ #}
#++ 
#++ 
#++ 
#++ 
# Accessors
#++ sub formatted_aa_change  { shift->{formatted_aa_change};  }
#++ sub formatted_nt_change  { shift->{formatted_nt_change};  }
#++ sub wt_protein_fragment  { shift->{wt_protein_fragment};  }
#++ sub mut_protein_fragment { shift->{mut_protein_fragment}; }
#++ sub wt_aa_start          { shift->{wt_aa_start};          }
#++ sub wt_trans_length  {
#++   my $self = shift;
#++   return $self->{wt_trans_length} if $self->{wt_trans_length};
#++   my $wt_trans = $self->{wt_trans};
#++   return length $wt_trans;
#++ }
#++ sub wt_trans      { shift->{wt_trans}; }
#++ sub mut_trans     { shift->{mut_trans}; }
#++ sub wt_unspliced  { shift->{wt_unspliced}; }
#++ sub mut_unspliced { shift->{mut_unspliced}; }
#++ 
#++ 



#++ # Need to generalize this for all alleles
#++ sub do_manual_conceptual_translation {
#++     my ($self,@p) = @_;
#++     my ($cds) = rearrange([qw/CDS/],@p);
#++ 
#++     my ($wt_nuc,$mut_nuc,$wt_full,$mut_full,$debug) = $self->build_sequence_strings(-flank=>'20');
#++     return unless ($wt_nuc && $mut_nuc);
#++ 
#++     my $var  = $self->variation;    
#++ 
#++     # Now that I have the full segment, map the position of the wildtype fragment
#++     # It might be necessary to find the reverse complement
#++     # Stitch together the dna of all features
#++     
#++     my $segment = $self->cds_segment($cds);
#++     # $cds_segment->refseq($segment);
#++     my $wt_unspliced = $segment->dna;
#++     
#++     # Save the coordinates of the exons
#++     my @exon_boundaries;
#++     my $wt_spliced;
#++     foreach ( sort {$a->start <=> $b->start}
#++ 	      grep { $_->name =~ /$cds/ }
#++ 	      $segment->features('coding_exon:Coding_transcript')) {
#++ 	# 0-based indexing
#++ 	push (@exon_boundaries,[$_->start,$_->stop]);
#++ 	$wt_spliced .= $_->dna;
#++     }
#++     
#++ 
#++     # There is apparently no consistency in strandedness of the flanking sequence
#++     # stored in the DB. Revcomp the flanks if we do not match
#++     $wt_nuc =~ s/\-//g;    # Let's ignore insertions and deletions
#++     $mut_nuc =~ s/\-//g;
#++     $debug .= "WT STRING ......... ............. : $wt_nuc"  . br if DEBUG_ADVANCED;
#++     $debug .= "MUT STRING ...................... : $mut_nuc" . br if DEBUG_ADVANCED;
#++     
#++     if ($wt_unspliced =~ /$wt_nuc/i) {
#++     } else {
#++ 	$wt_nuc = reverse $wt_nuc;
#++ 	$wt_nuc =~ tr/[acgt]/[tgca]/;
#++ 	$mut_nuc = reverse $mut_nuc;
#++ 	$mut_nuc =~ tr/[acgt]/[tgca]/;
#++ 	
#++ 	
#++ 	$debug .= "WT STRING REVCOMPED  : $wt_nuc" . br if DEBUG_ADVANCED;
#++ 	$debug .= "MUT STRING REVCOMPED : $mut_nuc" . br if DEBUG_ADVANCED;
#++     }
#++     
#++     # Hmmmmm.  Now, let's replace this section with the mutant sequence...
#++     # I need to create pseudo GFF segments for the spliced and unspliced
#++     my $mut_unspliced = $wt_unspliced;
#++     
#++     my $test = $mut_unspliced =~ s/$wt_nuc/$mut_nuc/i;
#++     
#++     if (DEBUG_ADVANCED) {
#++ 	if ($wt_unspliced eq $mut_unspliced && !$test) {      
#++ 	    $debug .= "!!! WT_UNSPLICED eq MUT_UNSPLICED --> something went wrong" . br;
#++ 	} else {
#++ 	    $debug .= " ----> WT UNSPLICED SUCCESSFULLY SUBSTITUTED WITH MUT" . br;
#++ 	}
#++     }
#++     
#++     
#++     # Create the mutant spliced
#++     # This my be incorrect if there is a splice mutant / deletion
#++     my $mut_spliced;
#++     foreach (@exon_boundaries) {
#++ 	my ($start,$stop) = @$_;
#++ 	my $dna = substr($mut_unspliced,$start-1,$stop - $start + 1);
#++ 	$mut_spliced .= $dna;
#++     }
#++     
#++     # Do a conceptual translation but only of allele is listed as
#++     # frameshift, missense, nonsense
#++     my $aa_type = $self->aa_type;
#++     
#++     if ($aa_type) {
#++ 	# Create a truncated string of the translated wild type and mutant
#++ 	# Calculate the position of the amino acid change
#++ 	my $wt_trans  = translate_as_string($wt_spliced);
#++ 	my $mut_trans = translate_as_string($mut_spliced);
#++ 	if ($mut_trans eq $wt_trans && DEBUG_ADVANCED) {
#++ 	    $debug .= "!! MUT TRANSLATION == WT TRANSLATIONS --> something went wrong..." . br;
#++ 	}
#++ 
#++ 	my ($change,$pos);
#++ 	if ($aa_type eq 'Nonsense') {
#++ 	    $mut_trans =~ /\*/g;
#++ 	    $pos = pos($mut_trans);
#++ 	    my $wt_aa = substr($wt_trans,$pos-1,1);
#++ 	    $change = uc $wt_aa . $pos . 'stop';
#++ 	} elsif ($aa_type eq 'Missense') {
#++ 	    # Find the amino acid that differs by comparing char by char - stoopid
#++ 	    my $c = 0;
#++ 	    my @mut_chars = split(//,$mut_trans);
#++ 	    my @wt_chars  = split(//,$wt_trans);
#++ 	    foreach (@mut_chars) {
#++ 		if ($mut_chars[$c] eq $wt_chars[$c]) {
#++ 		    $c++;
#++ 		    next;
#++ 		} else {
#++ 		    $pos = $c+1;   # 1-based
#++ 		    $change = uc $wt_chars[$c] . $pos . uc $mut_chars[$c];
#++ 		    last;
#++ 		}
#++ 	    }
#++ 	}
#++ 	
#++ 	# Store some data for easy accession
#++ 	# I'd like to purge this but it's deeply embedded in the logic
#++ 	# of presenting a detailed view of the sequence
#++ 	$self->{wt_aa_start} = $pos;
#++ 	
#++ 	# I should be formatting these here depending on the type of nucleotide change...
#++ 	$self->{formatted_aa_change} = $change;
#++ 	$self->{wt_protein_fragment} = ($pos - 19) . '...' . substr($wt_trans,$pos - 20,19) 
#++ 	    . ' ' . b(substr($wt_trans,$pos-1,1)) . ' ' .substr($wt_trans,$pos,20) .  '...' . ($pos + 19);
#++ 	$self->{mut_protein_fragment} = ($pos - 19) . '...' . substr($mut_trans,$pos - 20,19) 
#++ 	    . ' ' . b(substr($mut_trans,$pos-1,1)) . ' ' . substr($mut_trans,$pos,20) .  '...' . ($pos + 19);
#++ 	$self->{wt_spliced}    = $wt_spliced;
#++ 	$self->{mut_spliced}   = $mut_spliced;
#++ 	
#++ 	$self->{wt_trans_length} = length($wt_trans);
#++ 	$self->{mut_trans_length} = length($mut_trans);
#++ 
#++ 	# Just assume that the length is 1 for these (postiion 3)
#++ 	$self->{wt_trans} = 
#++ 	    "> $cds"
#++ 	    . $self->do_markup($wt_trans,$pos-1,1,undef,'is_peptide');
#++ 	
#++ 	$self->{mut_trans} = 
#++ 	    "> $cds ($var: $change)"
#++ 	    . $self->do_markup($mut_trans,$pos-1,1,undef,'is_peptide');
#++ 	
#++ 	
#++ ##	$self->{wt_trans}      = $self->to_fasta($cds,$wt_trans);
#++ ##	$self->{mut_trans}     = $self->to_fasta("$cds ($var: $change)",$mut_trans);
#++     }
#++     
#++     $self->{wt_unspliced}  = $wt_unspliced;
#++     $self->{mut_unspliced} = $mut_unspliced;    # This should be marked up...
#++     return ($self->{wt_protein_fragment},$self->{mut_protein_fragment},$self->{wt_trans},$self->{mut_trans},$debug);
#++ }
#++ 
#++ 
#++ 
#++ 
#++ 
#++ 
#++ 
#++ 
#++ sub to_fasta {
#++     my ($self,$name,$sequence,$skip_spaces) = @_;
#++     $sequence ||= '';
#++     my @markup;
#++     for (my $i=0; $i < length $sequence; $i += 10) {
#++ 	if ($skip_spaces) {
#++ 	    # Don't add markup for flanking sequences
#++ 	    push (@markup,[$i,$i % 80 ? '' : "\n"]);
#++	} else {	
#++	    push (@markup,[$i,$i % 80 ? ' ':"\n"]);
#++	}
#++    }
#++
#++    markup(\$sequence,\@markup);
#++    return ">$name<br>$sequence";
#++ }
#++ 
#++ # insert HTML tags into a string without disturbing order
#++ sub markup {	
#++     my $string = shift;
#++     my $markups = shift;
#++     for my $m (sort {$b->[0]<=>$a->[0]} @$markups) { #insert later tags first so position remains correct
#++ 	my ($position,$markup) = @$m;
#++ 	next unless $position <= length $$string;
#++ 	substr($$string,$position,0) = $markup;
#++     }
#++ }



