#!/usr/bin/perl
# -*-mode: perl-*-
# $Id: blat,v 1.74 2005/03/31 16:55:31 canaran Exp $
# blast search script used at the CSHL site.
# This contains some hard-coded path names, which will
# need to be edited for your site.  By default, this
# script is not included among the other search scripts.
# Also see util/dump_genomic.pl for the script used to
# make the DNA dump searched by this script.
# $Id: blat,v 1.74 2005/03/31 16:55:31 canaran Exp $


####  POSSIBLE BUG.  If BLAT doesn't work, search for 'weird' in this document
#### for a possible strategy
####

use lib '../lib';
use strict;
#use Data::Dumper;
use Ace;
use CGI qw/:standard escapeHTML Sub *table center/;
use IO::File;
use IO::String;
use Ace::Browser::AceSubs qw(:DEFAULT Configuration);
use Ace::Browser::SearchSubs;
use ElegansSubs;
use Bio::SearchIO;
use Bio::Graphics;
use Bio::Graphics::Feature;
use Bio::DB::GFF;

use vars qw/$TMPNAM $TMPDIR $TMP_BLAT $TMP_FILE %BLAST_OPTS $DB
  $cutoff $max_hits %flags %ok_databases/;

BEGIN {$|=1}
use constant DEBUG            => 1;
use constant BLAT_SERVER      => 1;
use constant SEQVIEW          => "/db/seq/gbrowse";
use constant MAX_LENGTH       => 50_000;
use constant BLAT_PATH_FLY    => "/usr/local/bin/";
use constant BLAT_PATH_SERVER => "/usr/local/wormbase/";
use constant DB_PATH          => "/usr/local/wormbase/blast/";
use constant GBROWSE          => "/db/seq/gbrowse/wormbase?";
use constant CBBROWSE         => "/db/seq/gbrowse/briggsae?";
use constant BLAT_CLIENT      => "/usr/local/blat/bin/gfClient localhost 2003";
use constant BLAT_CLIENT_B    => "/usr/local/blat/bin/gfClient localhost 2004"; # Added to direct briggsae searches - 5/10/04 PC
use constant THIS_URL         =>  url(-full=>1);
use constant DIRECT_TO        => Configuration->Blast2wormbase;

%flags = (); # Initialize %flags in mod_perl env, it determines whether search page is displayed /PC

%BLAST_OPTS= ('blastn'   =>  [qw/-hspmax 10/], # [qw/-progress 2 -hspmax 10/], # '-progress' option causes new wublast (march 2005) to hang unexpectedly, removed it
	      'blastx'   =>  [qw/-hspmax 10/], # [qw/-progress 2 -hspmax 10/],
	      'blastp'   =>  [qw/-hspmax 10/], # [qw/-progress 2 -hspmax 10/],
	      'tblastn'  =>  [qw/-hspmax 10/], # [qw/-progress 2 -hspmax 10/],
	     );

$DB = OpenDatabase() || AceError("Couldn't open database.");

PrintTop(undef,undef,'BLAST or BLAT Search');
# PrintTop subroutine of ElegansSubs needs work.
#{
#			    '-Title'  =>'BLAST or BLAT Search',
#			    '-Target' =>'_top',
#			    '-Class'  =>'search',
#			    '-xbase'  => Configuration->Blast2wormbase,
#			   }
#	);

$TMPNAM = 'aaaaaa';
$TMPDIR = $ENV{'TMPDIR'} || $ENV{'TEMP'} || '/usr/tmp';

# Cutoffs and Max_hits
$cutoff   = defined param('cutoff')  ? param('cutoff')   : Configuration->Blast_cutoff;
$max_hits = defined param('max_hits')? param('max_hits') : Configuration->Blast_maxhits;
$max_hits = 99999999 if $max_hits eq 'ALL';

#$cutoff = 10;# unless $cutoff=~/^[.eE\d-]+$/;
$cutoff = 9999 unless $cutoff=~/^[.eE\d-]+$/;

do_autoload() if param('autoload');

if (param('sequence') && param('action')=~/BLAST/) {
  # check that the search program matches the search database
  %ok_databases = map{$_=>1} @{Configuration->Blast_ok->{param('program')}};

  if (param('program') eq "BLAT"){
    $flags{db_ok}++ if param('db') ne "WormPep";
  }
  if ($ok_databases{param('db')} || ($flags{db_ok})) {
    do_search( param('sequence'),param('name'),param('program'),
	       param('db'),$max_hits,$cutoff );
    $flags{done}++;
  } else {
    print p({-class=>'error'},"You have chosen an incompatible combination of search program and database. Please adjust."
  	   );
  }
}

do_prompt() unless $flags{done};

PrintBottom;
#-----------------------------  END PROGRAM -----------------------------------


sub do_prompt {
  my $labels = Configuration->Blast_labels;
  my ($def_program,$def_db) = @{Configuration->Blast_default};
  DisplayInstructions('',
		      #'Blast or Blat Search',
		      'Paste your sequence into the large text field and enter its name (optional).',
                      'Press the "Run Blast or Blat " button to perform a search against all sequences in the database.');
  print start_form(-action=>Configuration->Wormbase2blast . "/db/searches/blat"),
  table({-class=>'searchbody',width=>'100%'},
	TR(
	   th ({-class=>'searchtitle'},'BLAST or  BLAT Search')
	  ),
	TR(
	   td({-align=>'center',-class=>'searchbody'},
	      font({-size=>'-1'},b('Seq. name (Opt.):')), 
	      textfield(-name=>'name', -size=>'10'),
	      '&nbsp;&nbsp;',
	      font({-size=>'-1'},b('Program: ')),
	      popup_menu(-name=>'program',
			 -value=>[qw/BLAT blastp blastn blastx tblastn/],
			 -default=>$def_program),
	      font({-size=>'-1'},'&nbsp;',b('Database: ')),
	      popup_menu(-name=>'db',-value=>$labels,-default=>$def_db)
	     )
	  ),
	TR(
	   td({-align=>'center',-class=>'searchbody'},
	      font({-size=>'-1'},b('Expected threshold: ')),
	      popup_menu(-name=>'cutoff',
			 -value=>[qw/1E-100 1E-50 1E-10 1E-5 0.001 0.01 0.1 9999 BLAT/],
			 -value=>[qw/0.0001 0.01 1.0 10 100 1000 BLAT/],
			 -labels => {0.01 => '0.01 (default)'},
		        # -labels => {9999 => 'NONE'},
			 -default=> 0.01), 
	      '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;',
	      font({-size=>'-1'},b('Show max hits:')),
	      popup_menu(-name=>'max_hits',
			 -value=>[qw/1 5 10 15 20 50 100 ALL/],
			 -default=>$max_hits,
			),
	     )
	  ),
	TR(
	   td({align=>'center',-class=>'searchbody'},
	      font({-size=>'-1'},b('Sequence (raw or FASTA format):')),
	      br,
	      pre(tt(textarea(-name=>'sequence',-rows=>12,-cols=>80))),
	      br,br,
	      submit(-name=>'action',-value=>'Run BLAST or BLAT'),
	      '&nbsp;'x10, reset (),
	      br,br,
	     )
	  ),
       ),
	 end_form;
  
  print
    table(Tr({-class=>'searchtitle'},
	     th ['Program','Search Seq','Database(s)']),
	  Tr({-class=>'searchbody'},
	     td ['BLAT*','nucleotide','elegans ESTs, elegans genomic']),
	  #	Tr({-class=>'databody'},
	  #	   td ['BLAT protein','protein', 'WormPep']),
	  Tr({-class=>'searchbody'},
	     td ['blastp','protein','WormPep']),
	  Tr({-class=>'searchbody'},
	     td ['blastn','nucleotide','elegans ESTs, elegans genomic']),
	  Tr({-class=>'searchbody'},
	     td ['blastx','nucleotide','WormPep']),
	  Tr({-class=>'searchbody'},
	     td ['tblastn','protein','elegans ESTs, elegans genomic'],
	    ),
	 ); # end of table
  print p("*BLAT: The BLAST-Like Alignment Tool is designed to quickly
  find sequences of 95% and greater similarity of length 40 bases or
  more.  It may miss more divergent or shorter sequence alignments.
  It was written by James Kent of UCSC. (email",
	a({-href =>'mailto:jim_kent@pacbell.net'},
	  "jim_kent\@pacbell.net"),")",
       );
} # end of sub do_prompt


###############################################################################
sub do_search {
  my ($sequence,$name,$program,$db,$max_hits,$cutoff) = @_;
  warn "blast/blat length = ",length $sequence if DEBUG;

  if (length $sequence > MAX_LENGTH) {
    print p({-class=>'error'},
	    "This program cannot accept sequences of length greater than ${\MAX_LENGTH} bp.");

    return;
  }

  if ((length $sequence < 25) and ($program eq "blastn")){
    print p({-class=>'error'},
	    "Sorry, $program can only accept sequences that are at
	    least 25bp long.  Your sequence is only ", length
	    $sequence , "bp.  Please try using the 'Browse Genome'
	    link for shorter sequences."
	   );
    return;
  }

  # Make temp file and Do blast
  $name = "My_Query" if !$name;
  if ($sequence !~/^>/) {$sequence = ">$name\n".$sequence;}

  local(*B);
  $TMP_FILE = tmpnam('.fasta');
  $TMP_BLAT = tmpnam('.psl');
  $name = to_fasta($TMP_FILE,$sequence,$name);

  # parse the hits and turn into nicely formatted HTML
  print h2('Results Summary',);
  #****************************************************************************
  if ($program =~ /blast/){
      my $path = Configuration()->Blast_bin . "$program";
      print "Path: $path\n" if DEBUG;
      print "Database: $db\n" if DEBUG;

      # This approach (setting env variables) chokes on some architectures
      # Instead we will pass the variables directly to blast
      #open(B,"-|") || do {
      #   @ENV{qw/BLASTMAT BLASTFILTER BLASTDB/} = (Configuration->Blast_matrix,
      #					  Configuration->Blast_filter,
      #					  Configuration->Blast_db);
      #
      #   my @opts = @{$BLAST_OPTS{$program}};
      #	 push (@opts,'-B=1000','-V=1000') if $max_hits > 101;
      #	 exec($path,$db,$TMP_FILE,@opts) && die "Couldn't exec: $!";
      # }; # end do

      my @blast_variables =
	('-putenv','WUBLASTDB='.Configuration->Blast_db,
	 '-putenv','WUBLASTMAT='.Configuration->Blast_matrix,
	 '-putenv','WUBLASTFILTER='.Configuration->Blast_filter);

      open(B,"-|") || do {
	my @opts = @{$BLAST_OPTS{$program}};
	push (@opts,'-B=1000','-V=1000') if $max_hits > 101;
	#  print join(' ',  $path,$db,$TMP_FILE,@opts,@blast_variables);
    exec($path,$db,$TMP_FILE,@opts,@blast_variables)
	  || die "Couldn't exec:$!";
      }; # end do

      my ($hits_AofH,$result) = blast_data(\*B);    # Get blast result
      do_blast_stuff($hits_AofH,$result);
    } # end if blast

  #****************************************************************************
  if ($program   =~/BLAT/){
    my $blat;
    my $command;
    my $db_path = DB_PATH. $db; 
    #my $testfile    = '/var/tmp/test.fa';

    if (BLAT_SERVER) {
      # Addition 5/10/04 - PC
	  # This script doesn't handle multiple blat servers. Added new constant to handle the briggsae genome searches.
	  # To be consistent with the current setup, the way blat directory is defined is maintained.

      if ($db eq 'Elegans') { $blat = BLAT_PATH_SERVER. lc $program; }
      elsif ($db eq 'Briggsae_genomic') { $blat = BLAT_PATH_SERVER. lc $program . '/briggsae'; }
      else { die "Cannot determine which database to search (database selection $db is not valid" }

      # Sth weird going on.  If this doesn't work, replace "/" in the command
      # with $blat and comment out the system command 
      # i.e. either need lines 1 and 2, or line 3

      # TH: Here's what's going on:
      # The format of the command depends on how the blat server was started
      # If it was started by:
      #       cd /usr/local/wormbase/blat
      #       /usr/local/blat/bin/gfServer start localhost 2003 *.nib &
      #       Then lines 1 and 2 should be used which provides a relative path to the *.nib files
      # If it was started by:
      #       /usr/local/blat/bin/gfServer start localhost 2003 /usr/local/wormbase/blat/*.nib &
      #      then line 3 should be used which provides the absolute path
      # NOTE: update_wormbase.pl uses the second syntax

      # Addition 5/10/04 - PC
	  # This script doesn't handle multiple blat servers. Added new constant to handle the briggsae genome searches.
	  # To be consistent with the current setup, the selection between line1-2 and line3 is maintained
	  # Please note that, the elegans nib file directory is /usr/local/wormbase/blat whereas briggsae nib files are created in /usr/local/wormbase/blat/briggsae

      if ($db eq 'Elegans') {		
	      #system ("cd /usr/local/wormbase/blat");   # line 1
	      #$command = BLAT_CLIENT." $blat $TMP_FILE  $TMP_BLAT";# -nohead"; #line2
    	  $command = BLAT_CLIENT . " / $TMP_FILE  $TMP_BLAT -nohead";  #line 3
		  }
      elsif ($db eq 'Briggsae_genomic') {		
	      #system ("cd /usr/local/wormbase/blat/briggsae");   # line 1
	      #$command = BLAT_CLIENT_B." $blat $TMP_FILE  $TMP_BLAT";# -nohead"; #line2
    	  $command = BLAT_CLIENT_B . " / $TMP_FILE  $TMP_BLAT -nohead";  #line 3
		  }
      else { die "Cannot determine which database to search (database selection $db is not valid" }

    } else {
      $blat    = BLAT_PATH_FLY. lc $program;
      $command = "$blat $db_path $TMP_FILE  $TMP_BLAT";
    }

    open STDERR,">&STDOUT";
     print "Command: $command \n" if DEBUG;
    open (B,"-|") || do {
      delete $ENV{REQUEST_METHOD};
      exec $command or die "arrrgggh:exec failed  $!";
      exit 0;
    };
    my $result = close B;
    warn "blat done, result = $result...\n" if DEBUG;

    blat_info($TMP_BLAT, $program, $db, $max_hits, $cutoff, $name, $sequence);
  }
}  # end of sub do_search
#------------------------------------------------------------------------------


###############################################################################
sub to_fasta {
  my ($tmp,$sequence,$name) = @_;
  if ($sequence=~/^>(.+)$/m) { #fasta format already
    $name = $1;
    $sequence=$';
  }
  $name ||= 'Untitled Sequence submitted by ' . remote_host();
  $sequence=~tr/a-zA-Z//cd;
  $sequence=~s/(.{80})/$1\n/g;

  my $file = IO::File->new(">$tmp") 
    || AceError("Couldn't open temporary file for writing sequence: $!");

  print $file ">$name\n$sequence";
  $file->close();
  $name;
}


###############################################################################
sub do_blast_stuff {
  my $hits_AofH= shift;
  my $result = shift;
  if (DEBUG){
  for (@$hits_AofH){
    my %t = %$_;
    for (keys %t){
      print $t{'hit'}->significance,hr;
    }
  }
}

  if (!($hits_AofH)) { print h4("Sorry no hits"); exit;}

  my @rows = TR(th(['Sequence','Description','Details','High Score','E-value','Num. of HSPs']));
    #    TR(th(['Sequence','Description','Details','High Score','P'.Sub('N'),'Num. of HSPs']));

  my $qname = $hits_AofH->[0]->{qname};
  my $panel = prep_image ( $qname, $hits_AofH->[0]->{qlength} );

  my $hits = 0;
  my $count = 0;
  my %align;
  my @gbrowse_links;               # stores gbrowse links for hsp printout
  my @image_hits;                  # stores all the hit obj for the image
  my @select_hits;
  if ($qname !~ /^My_query/) {$qname .= "_[MY_QUERY]";}

  foreach (@{$hits_AofH}){
    last if $hits >= $max_hits;
    $hits++;
    my $significance = $_->{hit}->significance;
    warn $significance, "...is significance\n" if DEBUG;
    next if $significance > $cutoff;
    push (@select_hits, $_);

    my $hname = $_->{hit}->name;
    $align{$hname}++;

    my $n =  eval { scalar @{$_->{hsps}} };
    my $descript = $_->{hit}->description;
    $descript =~s/^(.{55}).*/$1/;  # just get first 55 char of descriptn

    my $gbrowse = get_gbrowse_site($_->{hsps},$hname, $qname, "BlastHSPs_from_Query");
   push (@gbrowse_links, $gbrowse);

    #************************************************************************
    # Add to table
    push(@rows,
	 TR(th({-align=>'LEFT'},
	       a({-href=>DIRECT_TO.to_tree($hname),-name=>$hname},$hname)),
	    td($descript,"..." ),
	    td((a{-href=> THIS_URL."\#${hname}_hsp"},'Alignment,'),
	       $gbrowse ? (a{-href=>DIRECT_TO."/$gbrowse"},"Genome View") : ''),
	    td($_->{hit}->raw_score),
	    td($significance),
	    td($n)
	   ));

    #************************************************************************
    # Prepares hits image information
    my @hsps;
    for my $eachhsp (@{$_->{hsps}}){
      # find where hsps hit in query coordinates
      my $hsp_obj = Bio::Graphics::Feature->new(-start  => $eachhsp->start,
						-end    => $eachhsp->end,
						-score  => $eachhsp->score,
					       );
      push (@hsps, $hsp_obj);
    }
    my $hit_image = Bio::Graphics::Feature->new(-segments => \@hsps,
						-name    => $hname,
					       );

    $panel->add_track(segments => $hit_image,
		      -label   => 1,
		      -height  => 6,
		      -bgcolor => \&colour,
		   );
  } # end foreach .@{$hits_AofH}....

  #***************************************************************************
  # Print image and table
  my $image_gd =  $panel->gd;
  my $image_url = AceImage($image_gd);
  print center(img({-src=>$image_url}));

  print br();
  print table({-border=>undef,-width=>'100%'},
	      join("\n",@rows)),"\n" if $hits > 0;

  $count = scalar keys %align;
  my $default_cut = $cutoff == 0.01? "default" : "";
  #  my $default_cut = $cutoff == 9999? "default" : "";
  print p(strong({-style=>'color: red'},"$hits hits total ($count above $default_cut expected threshold of $cutoff)"));

  # return to search page button
  if (0) {
    print start_form;
    print hidden($_) foreach qw(sequence name db program cutoff max_hits);
    print submit(-name=>'action',-value=>'Search Again'),
      end_form;
  } # end of if


  print hr,h2('Alignments') if $count > 0;
  prepare_print_hsp(\@select_hits, \%align, \@gbrowse_links); # print HSPaligns

  close B;

  my @parameters = $result->available_parameters;
  @rows = ();
  foreach (@parameters) {
    push @rows,TR(th({-class=>'datatitle'},$_),td({-class=>'databody'},$result->get_parameter($_)));
  }
  print h3('BLAST parameters');
  print table({-border=>1,-width=>'100%'},@rows);
} # end of do_blast_stuff


###############################################################################
sub prep_image {
  my ($qname, $qlength) = @_;
  my $bgf = 'Bio::Graphics::Feature';

  # Create scoring track
  my @score_blocks;    # stores a coloured bar for each score range
  my @key_score = (  10,   45,    79,    199,     201 );
  my @key_label = ("<40","<50", "<80", "<200", ">=200");
  my $spacing = ($qlength-1)/6 ;          # for the layout of the score key
  my $position =1;

  for (my $i =0; $i <5; $i++){
    my $tmp_block= $bgf->new(-segments=>[
					 $bgf->new (
						    -start => $position,
						    -end =>$position +$spacing,
						    -score=>$key_score[$i]),
					],
			     -name   => $key_label[$i],
			    );
    $position += $spacing + $spacing/4;

    push (@score_blocks, $tmp_block);
  }

  my $query_image= $bgf->new (-start  => 1,
			      -end    => $qlength+1 ,
			      -name   => $qname,
			      -strand => 1);

  my $panel = Bio::Graphics::Panel->new (-segment    => $query_image,
					 -width      => 800,
					 -pad_bottom => 20,
					);

  $panel->add_track (segments    => \@score_blocks,
		     -label      => sub {
		       my $feature = shift;
		       my $label = $feature->name;
		       return $label;
		     },
		     -bgcolor => \&colour,
		    );

  $panel->add_track (arrow    => $query_image,
		     -tick    => 2,
		     -height  => 6,
		     -label   => 1,
		    );
  return ($panel);
}


###############################################################################
sub colour {
  my $feature = shift;
  my $score   = $feature->score;
  return 'lavenderblush' if $score < 40;
  return 'peachpuff'     if $score < 50;
  return 'thistle'       if $score < 80;
  return 'mediumorchid'  if $score <200;
  return 'purple';
}

###############################################################################
sub get_gbrowse_site {
  my ($block_start, $hit, $query, $name, $block_size)=@_;
  my $highest = $block_start->[0];  # end of last block
  my $lowest = $block_start->[0];   # start of first block
  my $pep = param('db') =~ /pep/;

 my $ranges;                   # string of block ranges
  foreach my $start (@$block_start){
    if ($block_size){
 	my $tmp_stop = (shift @$block_size) + $start;
	$ranges .= $start."-".$tmp_stop.",";

	for ($start, $tmp_stop){
	  $lowest = $_ if $_ < $lowest;
	  $highest = $_ if $_ > $highest;
	}
      }
    else {$ranges .= $start->hstart."-".$start->hend.",";}
 }
  chop $ranges;                  # get rid of the last extra ","
  $hit =~ s/CHROMOSOME_//;

  # For the blat hits need to define display region (1000 bp either side)
  $highest += 1000;
  $lowest -=1000 if $lowest >1000;
  # Only add in these range restrictions for the blat display
  my $add_in = $name =~/^Blast/?"": ":$lowest..$highest";

  # transform protein to gene name
  if ($pep) {
    my $protein = $DB->fetch(Protein=>$hit);
    $hit = $protein->Corresponding_CDS if $protein;
  }

  my $gbrowse = (param('db') =~ /brig/i ? CBBROWSE : GBROWSE). ($pep ? "name=$hit$add_in" 
                                                                     : "name=$hit$add_in;auto=$hit+$name+$query+$ranges");
  #print "$gbrowse <BR>" if DEBUG;

  return $gbrowse;
}

###############################################################################
sub prepare_print_hsp {
  my $hits_AofH = shift;
  my $show = shift;                         # \$align
  my $gbrowse_links = shift;

  # Generate a link to gbrowse to view the hits on the genome.
  # print @$gbrowse_links;


  my $count_hits=0;                         # count hits for gbrowse link
  my $url = url(-absolute=>1);

  for my $each_hit (@$hits_AofH) {
    # see if it is true
    my $description = $each_hit->{hit}->description;
    my $hit = $each_hit->{hit}->name;
    return unless $show->{$hit};            # exit unless this is really a hit
    print p(h3
	    (a({-href=>DIRECT_TO.to_tree($hit),-name=>"$hit"."_hsp"},escapeHTML($hit)),
	    '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;',
	     $gbrowse_links->[$count_hits] ? (a{-href=>DIRECT_TO."/$gbrowse_links->[$count_hits]"},"Genome View") : (),
	   ));
    $count_hits++;

    # fix something in the elegans database that I don't like
    $description =~ s!/cds=!/cds_count=!g;   # change /cds=x to /cds_counts=x
    $description = escapeHTML($description);
    $description =~ s/gb=(\w+)/'gb='.
      a({-href=>Configuration->Ncbi . "?db=n&form=1&field=Sequence+ID&term=$1"},$1)/meg;

    # $id = CHROMOSOME_X/12345,54321, $ref = CHROMOSOME_X, $start, $stop
    if ($description =~ m!/map=((\w+)\/(\d+),(\d+))!) {
      my ($id,$ref,$start,$stop) = ($1,$2,$3,$4);
      $ref =~ s/^CHROMOSOME_//;
      ($start,$stop) = ($stop,$start) if $stop < $start;
      $description =~ s{/map=(\S+)}
	{'/map=' . a({-href=>DIRECT_TO.SEQVIEW()."?name=$ref:$start..$stop"},$id)}me;
    }
    $description =~ s!/(\w+)=!b({-Style=>'color: red'},$1).'='!ge;
    print_hsp_info($description, $each_hit);
    print a({-href=>"$url#$hit"},"Summary table"),hr;
  } # end for foreach hit
  return 1;
} # end prepare_print_hsp


###############################################################################
sub print_hsp_info  {
  my ($description, $each_hit) = @_;

  print p({-class=>'small'},$description);
  print "<PRE>";

  for my $info (@{$each_hit->{hsps}}){
    my $identical = sprintf("%.0f",(100*$info->frac_identical(['query'])));
    my $positive  = sprintf("%.0f",(100*$info->frac_conserved(['query'])));
    my $strand = "Plus";
    if ($info->strand) {
      $strand =$info->strand>0 ? "Plus" : "Minus";
      print  "\n\n$strand Strand HSP\t";
    }
    print "Score: ",$info->score," (",$info->bits," bits) \t";
    print "Expected Threshold: ",$info->evalue," \n";
#    print "Sum P (",scalar @{$each_hit->{hsps}},"): ",$info->pvalue,"\n";
    print "Identities = $identical% \t";
    print "Positives = $positive% \t\t";
    print "Strand = $strand /Plus" if $info->strand;
    print "\n\n";

    my @query    = $info->query_string=~/.{1,60}/g;
    my @homology = map { s/\w/\|/g; $_ } $info->homology_string=~/.{1,60}/g;
    my @hit      = $info->hit_string=~/.{1,60}/g;
    my ($qstart,$qend) = ($info->start, $info->end);
    my ($hstart, $hend) = ( $info->hstart,$info->hend);
    ($qstart,$qend) = ($qend,$qstart) if $strand eq "Minus";

    print_alignment([$qstart,$qend,$hstart,$hend,$strand],
		    \@query,\@hit,\@homology);
  } # end for my $info
  print "</PRE>";
  return 1;
}

###############################################################################
sub print_alignment {
  my ($info,$query,$hit,$homology, $blat)= @_;
  my ($qstart,$qend,$hstart,$hend, $strand)= @$info;
  $strand = "Plus" if $blat;
#debug, jack
#map{print $_, hr;}@$info, "... here is info", hr if DEBUG;
#map{print $_, hr;}@$query, "... here is query", hr if DEBUG;
#map{print $_, hr;}@$hit, "... here is hit", hr if DEBUG;
#map{print $_, hr;}@$homology, "... here is homology", hr if DEBUG;
#print $blat, hr if DEBUG;
#print $query->[0], " is the first query seq", hr if DEBUG;
#print $homology->[0], " is the connectors", hr if DEBUG;
#print $hit->[0], " is the first hit seq", hr if DEBUG;

  # Error check
  if ($hstart > $hend)   {print "Error: $hstart is greater";}
  if ($strand eq "Plus") {print "Error start greater\n" if $qstart > $qend;}
  if ($strand eq "Minus"){print "Error stop graeter\n" if $qstart < $qend;}

   # Find start and stops Print out alignment
   my ($qtmp_end, $htmp_end);
   for my $i (0..$#$query){

     # Use sub to find out the end position of the first row of the alignment
     $qtmp_end = seq_positions($qstart, $i, $query, $strand);
     $htmp_end = seq_positions($hstart, $i, $hit, "Plus");

     $qstart = sprintf("% 20s", $qstart);
     my $spacer = sprintf("% 27s");
     $hstart = sprintf("% 20s", $hstart);

print "<PRE>"; 
print "Query: $qstart  $query->[$i]  $qtmp_end \n";
print "$spacer  $homology->[$i]\n";
print "Hit:   $hstart  $hit->[$i]  $htmp_end\n\n";
print "</PRE>";

     # Find the next start positions
     if ($i !=$#$query){
       if($query->[$i+1] =~/\w/)
	               {$qstart = $strand eq "Plus"? ++$qtmp_end: --$qtmp_end;}
       else{$qstart=$qtmp_end;  }
       if ($hit->[$i+1] =~/\w/)  {$hstart = ++$htmp_end;}
       else {$hstart =$htmp_end;}
     }
   } # end of foreach

  # Error check
  print "Error: in query start and stops. Stop = $qend"  if $qtmp_end != $qend;
  print "Error: in hit   start and stops. Stop = $hend"  if $htmp_end != $hend;
  return 1;
} # end sub print_alignment



###############################################################################
sub to_tree {
  my $hit = shift;
  return Object2URL($hit,param('db') =~ /pep$/ ? 'Protein' : 'Sequence');
}

###############################################################################
sub seq_positions{
  my ($start, $i, $sequence, $strand)= @_;
  my $count_bases = ($sequence->[$i] =~ tr/A-Za-z//);
  my $tmp_end;

  # If there are no bases at all, do not add to the count. 
  my $correct_4_base = $count_bases ? 1:0;
  if ($strand eq "Plus")    {$tmp_end= $start + $count_bases-$correct_4_base;}
  else  {$tmp_end= $start - $count_bases+$correct_4_base;}

  #print ("start $start, $strand, bases $count_bases, end $tmp_end");
  return ($tmp_end);
}
###############################################################################
# Find a temporary file name. 
sub tmpnam {
  my $suffix = shift;
  while(1) {
    my $tmpfile = "$TMPDIR/${$}" . $TMPNAM++ . $suffix;
    return $tmpfile if IO::File->new($tmpfile,O_EXCL|O_CREAT);
  }
}

##############################################################################
sub do_autoload {
  my $object = param('autoload');
  my ($id,$db) = $object =~ /^Blast (\S+) against (\S+)/;
  return unless $id && $db;
  my ($obj) = $DB->fetch(CDS => $id);
  ($obj) = $DB->fetch(Sequence => $id) unless $obj;
  return unless $obj;
  param(name => "$obj");
  param(db => $db);
  if ($db eq 'WormPep') {
    param(program => 'blastp');
    param(sequence => $obj->asPeptide);
  } else {
    param(program => 'blastn');
    param(sequence => $obj->asDNA);
  }
} # end of do_autoload


###############################################################################
# Blast data subroutines
sub blast_data {
  my $fh = shift;
  my @data;
  my $query_name;
  my $header;
  my $end_header =0;

  print "<PRE>\n";
  while( <$fh> ) {
    push @data, $_ ;
    if ( /^Query=(.*)/ ) {
      $query_name= $1;
      $query_name=~ s/^\s+|\s+$//g;       # rm leading or trailing wh space
      $query_name=~ s/\s+/_/g;             # replace " " with "_"
      if ($query_name =~/^Untitled/){$query_name = "My_query";}
      $end_header=1;
    }
    $header .= $_ if $end_header==0;
  }
  print "</PRE>\n";


  my $iostring = new IO::String(join('',@data));
  my $searchio = new Bio::SearchIO(-format => 'blast',
				   -fh => $iostring);
  my $global_result;
  my $hits_AofH;              # stores results
  while ( my $result = $searchio->next_result() ) {
    my $query_length = $result->query_length();
    # Print out header info
    print "<PRE>$header\n";
    print "Query:\t  $query_name ($query_length letters)\n";
    print "Database:\t  ", $result->database_name(),"\n";
    print "\t  Size: ",$result->database_entries();
    print "(", $result->database_letters, " letters)\n</PRE>";
    print "\n\n\t SCORE KEY:";

    while( my $hit = $result->next_hit ) {
      my $tmp_infoH;
      $tmp_infoH->{hit}=$hit;
      my $tmp_hsp_infoA;
      while( my $hsp = $hit->next_hsp()) {	
	push (@$tmp_hsp_infoA, $hsp);
      }# end of while $hsp

      $tmp_infoH->{hsps}   = $tmp_hsp_infoA;
      $tmp_infoH->{qname}  = $query_name;
      $tmp_infoH->{qlength}= $query_length;
      push (@$hits_AofH, $tmp_infoH);
    }# end of while $hit
    $global_result = $result;
  }# end of while $result

  return ($hits_AofH,$global_result);
} # end of blast_data


###############################################################################
sub blat_info {
  my ($result, $program, $db, $max_hits, $cutoff, $name, $qsequence) = @_;
  my $hit_count = 0;

  open (*B, $result) or die "Couldn't open $result $!";
  my @rows= TR(th(['Sequence','Strand','Details', '% of query length matched', 
		   '% Identity','Number of Blocks']));

  #****************************************************************************
  # Parse result file $TMP_BLAT
  my %table;                         # stores all the results for table
  my %alignment;                     # stores all the results for alignment

  while (<B>)
    {
      print "<PRE> $_ </PRE>" if DEBUG;
      next if $_ !~/^\d/;            # if the line begins with \d
      $hit_count++;

      my %hit;
      my @line_heads = qw(matches mismatches repeated_matches num_N qgaps
			  qgap_bases hgaps hgap_bases strand qname qlength
			  qstart qend hname hlength hstart hend num_blocks
			  block_sizes qblock_start hblock_start
			 );
      my @eachline = split (/\t/, $_);          # split on \t
      for my $value (@eachline){
	my $key = shift @line_heads;

	# Correct start and end query and hit positions for base zero
	$value++ if $key =~/[qh]start|end/;
	
	# For block sizes, qblock_start, hblock_start, split values into @tmp
	if ($key =~/block_/){
	  chomp ($value);
	  my @tmp_blocks = split (/,/,$value);

	  # Correct the qblock_start and hblock_start positions for base zero
          #debug, jack
	  if ($key =~/block_start/){
	    foreach (@tmp_blocks) {++$_;}          # correct for 0 base
	  } #debug, jack
	  $hit{$key}=\@tmp_blocks;

	  #print "<PRE>$key => @tmp_blocks</PRE>";
	}

	else {$hit{$key}=$value;}  # if an array is not built
      } # end of for my $value

      # Sort out the name
      my $qname = $name if $name;    # otherwise it will be from > line
      $qname    = "My_query" if (($hit{qname} eq "")or ($qname =~/^Untitled/));

      #************************************************************************
      # Find Ranges
      my @block_sizes = @{$hit{block_sizes}};
      my $gbrowse = get_gbrowse_site($hit{hblock_start},$hit{hname}, 
				      $qname, "BlatBLOCKS_from_Query",
				     \@block_sizes);

      #************************************************************************
      # Details for summary table
      my $hname           = $hit{hname};
      my $hlength         = $hit{mismatches}+$hit{matches};
      my $qlength_matched =sprintf("%.2f",(100* $hit{matches}/ $hit{qlength}));

      if ($hit_count <2) {
	print h3(b(a{-name=> "SummaryTable"},"Summary Table"));
	print p(b("Program:"),$program, br, b("Database:"),$db);
	print p(b("Query:  "),$qname,'&nbsp',"Length:",$hit{qlength}+1,"bp");
      }
      if ($hit_count ==0) { print h2("No hits");   exit;  }

      push (@{$table{$qlength_matched}{$hit_count}},
      	   TR({-align =>'CENTER'},
	      th({-align =>'LEFT'},
		 a({-href=>DIRECT_TO.to_tree($hname),-name=>$hname},$hname)),
	      td($hit{strand}),
	      td((a{-href=>THIS_URL."\#$hit_count"},"Alignment,"),
		 $gbrowse ? (a{-href=>DIRECT_TO."/$gbrowse"},"Genome View") : '' ),
	      td ($qlength_matched),
	      td (sprintf("%.2f",(100* $hit{matches}/ $hlength      ) )),
	      td($hit{num_blocks}),
	     ),
	   );
      #************************************************************************
      # Details for alignment
      $alignment{$qlength_matched}{$hit_count}=
	align_pic(\%hit,$qsequence,$qname,$db); # Added $db - 5/10/04 - PC
    } # end while

  #****************************************************************************
  # Print out summary table
  foreach my $set_of_results (sort {$b <=> $a} keys %table){
    foreach my $second_key (keys %{$table{$set_of_results}} )  {
      foreach ( @{$table{$set_of_results}{$second_key}} )   {
	last if $rows[$max_hits];             # stop once have max no. of hits
	push (@rows, $_);
      }
    }
  }


  # GUYS!  This is a total mess!  Please clean up your debugging when finished
  # and comment your algorithm if necessary
  if ($hit_count >0){
    print table({-border=>undef,-width=>'100%'}, join("\n",@rows)),"\n";
    my $printed_hits = $max_hits > $hit_count ? $hit_count: $max_hits;
    print p("$printed_hits hit(s) listed", em("(Total hits: $hit_count)."));
    print p(
	    b("Key"), br,em("% of query length matched:"),'&nbsp',
	    "number of matches/ query length", br,em("% identity:"),'&nbsp',
	    "number of matches / number of matches + mismatches",hr,
	   );

    my $alignments_printed =0;
    foreach my $row_of_results (sort {$b <=> $a} keys %alignment){
      foreach my $identifier (keys %{$alignment{$row_of_results}} )  {
	my $hname = shift ( @{$alignment{$row_of_results}{$identifier}->[0]} );
	$alignments_printed++;
	last if $alignments_printed > $max_hits;
	print h3("Alignment to $hname",'&nbsp',a({-name=>"$identifier"}),
		 "($row_of_results% of query matched)<PRE>");


	# Send the qstarts and stops etc, query alignment and hits alignment
	print_alignment(@{$alignment{$row_of_results}{$identifier}}, 1);
#	print Dumper(@{$alignment{$row_of_results}{$identifier}});
#debug, jack
#print $alignment{$row_of_results}{$identifier}->[1]->[0], "what....1", hr;
#print $alignment{$row_of_results}{$identifier}->[2]->[0], "what....2", hr;
#print $alignment{$row_of_results}{$identifier}->[3]->[0], "what....3", hr;
	print "</PRE>";
	print p(a{-href=>"\#SummaryTable"},"Summary Table");
      }# end of foreach identifier
    } # end  of foreach $row_of results
  } # end of if $hit_count > 0

  else {
    print p("Sorry, no results found for your query sequence.")if$hit_count==0;
  }
} # end sub blat-info

###############################################################################
sub align_pic{
  my ($hit, $q_seq, $qname, $db) = @_; # Added $db - 5/10/04 - PC

  # Unaligned query seq
#  $q_seq =~ s/>$qname//;    # remove the >name from the query q_seq
  $q_seq =~ s/>[^\n]+\n//;    # Line above modified as it causes headers that contain regex special chars to fail to remove the header: 30 April 2004 - PC
                              # eg >lin-1 (something something) would not be removed
  $q_seq =~ s/\s//g;               # rm spaces from the query q_seq

#debug, jack
#print $q_seq, "...raw query stuff", hr;
  # Get section of hit sequence that aligns to query

  # Addition 5/10/04 - PC
  # This script doesn't handle multiple blat servers. Added if statement to direct search.

  my $seq_db;
  if ($db eq 'Elegans') { 
    $seq_db = OpenDBGFF($DB) || die ("Couldn't open DBGFF database.");
  } elsif ($db eq 'Briggsae_genomic') {
    $seq_db = OpenBrigGFF($DB) || AceError("Couldn't open BRIGGFF database.");
  } else { 
    die "Cannot determine which database to search (database selection $db is not valid";
  }

  $hit->{hname} =~ s/^CHROMOSOME_//;

  my $db_start = $hit->{strand} eq "-"? $hit->{hend}-1  : $hit->{hstart};
  my $db_stop  = $hit->{strand} eq "-"? $hit->{hstart}-1: $hit->{hend};

  #my $h_seq=($seq_db->segment($hit->{hname},$db_start-2, $db_stop-2));
  my $h_seq=($seq_db->segment($hit->{hname},$db_start, $db_stop));

  #debug, jack, sep 17 (dec12, changed back to make alignment working)
  #the above line was changed to solve the off-by-one bug in the display.
  #it is not a perfect solution though, some sequences still cause problem.
  #for example:
  #>C01G6.7
  #caccgcaggaatggtaacgtttttttattattcgttttctaaactaaaatgttgtattcagaatactgcagcgtccacaggaccaatgaatttggttctcgataagtgtt

  #  print "$h_seq is positions" if DEBUG;
  $h_seq = $h_seq->dna;
#debug, jack
#print $h_seq, "...raw hit stuff", hr;
  #print "<PRE>q: $q_seq \n h: $h_seq</PRE>";
	
  # FORMULATE the aligned sequences
  my ($q_positions, $h_positions);
  my ($q_align, $h_align);

  my @block_sizes = @{ $hit->{block_sizes} };
  my @qblock_start= @{ $hit->{qblock_start} };
  my @hblock_start= @{ $hit->{hblock_start} };
  my @tmp_qstart;
  my @tmp_hstart;

  if ($hit->{strand} eq "-") {
    for my $i (0..$#block_sizes) {
      $tmp_qstart[$i] = $hit->{qlength} - $qblock_start[$i] - $block_sizes[$i] + 2; #$hit->{qend} -$qblock_start[$i]- $block_sizes[$i]+1;
      $tmp_hstart[$i] = $hblock_start[0] + $hit->{hend} - $hblock_start[$i]
	- $block_sizes[$i];
    }
    @block_sizes = reverse @block_sizes;
    @qblock_start = reverse @tmp_qstart;
    @hblock_start = reverse @tmp_hstart;
  }
  $block_sizes[-1] +=1; # need to correct for blat's zero base thing

  # There is an array of block sizes, qblock starts and hblock starts
  # Foreach block, cycle through these three arrays to construct aligned seqs
  for my $i ( 0..$#{$hit->{block_sizes}} ) {
    my $block_size   = $block_sizes[$i];
    my $curr_q_start = $qblock_start[$i];  # in base 1
    my $curr_h_start = $hblock_start[$i];  # in base 1
    my $curr_q_stop  = $curr_q_start + $block_size -1;  # cos started at pos 1
    my $curr_h_stop  = $curr_h_start + $block_size -1;
    # Correct for just using a segment of the genomic sequence
    my $offset = $hit->{hstart};

    # Get the substr from each seq that corresponds to the block of seq matched
    # The substr function in perl works from base 0 => have to rm 1
    $q_align .= substr($q_seq, $curr_q_start-1, $block_size);
    $h_align .= substr($h_seq, $curr_h_start -$offset, $block_size);
    #print "<PRE> $q_align\n $h_align \n</PRE>";
    #    print p("q start $curr_q_start, q stop $curr_q_stop, $block_size");

    # Is there a gap in the q between this block and the next?
    # Calculate next block start - current stop - 1 (min diff =1)
    if ($qblock_start[$i+1]){             # if there is a next block
      my $qgap = $qblock_start[$i+1] - $curr_q_stop -1;
      my $hgap = $hblock_start[$i+1] - $curr_h_stop -1;

      if (($hgap) and ($qgap)){
	if ($hgap > $qgap){
 	  my $adjust = $hgap- $qgap; # the h seq will be $adjust bases longer
 	  $q_align .=  "-" x $adjust;
 	}
 	# query gap is bigger so replace the difference with gaps in hit
 	else {  # the q seq will be $adjust bases longer
	 my $adjust =  $qgap- $hgap;
 	 $h_align .=  "-" x $adjust;
 	}
      }

      else{
	$h_align .= "-" x $qgap;
	$q_align .= "-" x $hgap;
      }
      $q_align .= substr($q_seq, $curr_q_stop, $qgap);
      $h_align .= substr($h_seq, $curr_h_stop-$offset, $hgap);
    }
  }# end of for $i blocks

#debug, jack
#print $q_align, " is the query seq before slicing", hr;
#print $h_align, " is the hit seq before slicing", hr;

  my @q_align = $q_align   =~/.{1,60}/g;
  my @h_align = $h_align   =~/.{1,60}/g;
  my @homology;

  # Create a homology string for the alignment
  for my $i (0.. $#q_align){
    my $length = length $q_align[$i];
    if (lc $q_align[$i] eq lc $h_align[$i]){
      $homology[$i] = "|" x $length;
    }
   elsif (($q_align[$i] !~/\w/) or ($h_align[$i] !~/\w/)){ # only gaps
      $homology[$i] = " " x $length if (($q_align[$i] !~/\-/) 
					or ($h_align[$i] !~ /\-/));  # no gaps
    }
    else {
      my @q_split = split //, lc $q_align[$i];
      my @h_split = split //, lc $h_align[$i];

      my $shortest = $#q_split > $#h_split ? $#h_split : $#q_split;
      for my $j (0.. $shortest) {
	$homology[$i] .= $q_split[$j] eq $h_split[$j]? "|": " ";
      } # end of for $j
    }# end of else
  } # end of for $i

#debug, jack
#print $q_align[0], "...processed query seq", hr;
#print $h_align[0], "...processed hit seq", hr;

 return ([[$hit->{hname}, $qblock_start[0], 
	  # $hit->{qblock_start}[-1]+ $block_sizes[-1]-1 ,     #qend
	   $hit->{qend},
	   $hit->{hstart}, $hit->{hend}, $hit->{strand}],
	  \@q_align,\@h_align, \@homology]);
} # end sub alignment

###############################################################################
END {
  unlink $TMP_FILE if $TMP_FILE;
  unlink $TMP_BLAT if $TMP_FILE;
}
